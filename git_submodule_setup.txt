Hereâ€™s the **short, to-the-point checklist** ğŸ‘

---

## Goal

Clone a repo **with submodules**, get them **working immediately**, and keep them **updated automatically** (without global settings).

---

## Steps (run in order)

### 1ï¸âƒ£ Clone the parent repo

```bash
git clone <REPO_URL>
cd <REPO_NAME>
```

---

### 2ï¸âƒ£ Pull all submodules (one-time)

```bash
git submodule update --init --recursive
```

ğŸ‘‰ This downloads the submodules **now**.

---

### 3ï¸âƒ£ Enable auto-update for this repo only

```bash
git config submodule.recurse true
```

ğŸ‘‰ Stored in:

```
.git/config
```

Note: If --global is passed, it will be saved under ~/.gitconfig.

ğŸ‘‰ Makes `git pull` update submodules automatically **for this repo only**.

---

## Thatâ€™s it.

### After this:

```bash
git pull
```

âœ… Parent repo updates
âœ… Submodules update automatically

---

## What NOT to do

* âŒ Donâ€™t edit or commit `.git/`
* âŒ Donâ€™t rely on `.gitattributes` for submodules
* âŒ Donâ€™t expect this to affect other peopleâ€™s machines

---

## For other users

They must run:

```bash
git submodule update --init --recursive
```

(or your setup script)

---

### Mental model

* Step 2 = **fix now**
* Step 3 = **prevent future problems**

Youâ€™ve got it.


Why .gitattributes cannot solve this

Submodules are stored as gitlinks (commit pointers)

.gitattributes only affects file handling

Git intentionally separates:

Behavior config â†’ .git/config, ~/.gitconfig

Content rules â†’ .gitattributes

This separation is a design choice, not a limitation.

Correct mental model:
Tool			Purpose
.gitattributes		How files are treated
.git/config		How Git behaves (local)
~/.gitconfig		How Git behaves (global)
README / scripts	Onboarding humans 

